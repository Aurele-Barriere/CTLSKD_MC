\documentclass{acmart}

\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{pgf,tikz}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{wrapfig}
\usetikzlibrary{positioning}

\title{Writing a CTLSKD Model-Checker in Ocaml}

\author{Aur\`ele Barri\`ere}

\date{December 2nd, 2018}


% macros
\def\ctls{CTL$^{*}$}
\def\ctlsk{CTL$^{*}$K}
\def\ctlskd{CTL$^{*}$K$\Delta$}
\def\ctlskdp{CTL$^{*}$K$\Delta\psi$}
\def\ltl{LTL}
\def\ap{AP}
\def\A{\mathit{A}}
\def\E{\mathit{E}}
\def\U{\mathit{U}}
\def\R{\mathit{R}}
\def\X{\mathit{X}}
\def\K{\mathit{K}}
\def\KP{\bar{\mathit{K}}}
\def\D#1{\Delta^{#1}}
\def\eq#1#2{\approx^{#2}_{#1}}
\def\eqh#1{\approx_{#1}}
\def\eqstate#1{\sim_{#1}}
\def\todo#1{{\color{red}#1}}
\def\iff{\ \mathit{iff}\ }
\def\UD{U_{\Delta}}
\def\UT{U_T}
\def\UDK#1{U_{\Delta #1}}
\def\UTK#1{U_{T #1}}
\def\FV{\mathit{FH}}
\def\FP{\mathit{FP}}
\def\ktree{$k$-tree}
\def\ktrees{$k$-trees}
\def\qed{\hfill$\blacksquare$}

\begin{document}
\maketitle

\section{Introduction}

Temporal Logics are a convenient formalism when it comes to reasonning about knowledge in dynamic systems.
Similarly, Epistemic Logics allow to describe and reason about knowledge in distributed systems, or systems with imperfect information.
Combining the two kinds of logics for Epistemic Temporal Logics is a popular field with many uses, as in Artificial Intelligence or Game Theory.
In many real-world applications, several agents are involved, each with its own view of the world, and things evolve dynamically.

In an earlier work [?], we defined a new Epistemic Temporal Logic, \ctlskd.
It extends the \ctlsk\ logic, a well-known epistemic extension of \ctls, a popular temporal logic.
While \ctlsk\ added to \ctls\ the $\K$ operator to model agents knowledge, \ctlskd\ adds the operator $\Delta$, that allows agents to change their ``observational power'', or their point of view on the system.
For instance, the formula $\D{o}\K\A\X p$ means that after changing to an observation o, the agent knows that, on the next step, the proposition p will hold, whatever path has been taken by the system.
To the best of our knowledge, this was the first time that such a change was enabled in an Epistemic Temporal Logic.

For Epistemic and/or Temporal Logics, model-checking (deciding if a formula is true in a model) is an important problem, as it allows to confront a specification and the modelization of a system.
In [?], we showed that model-checking \ctlskd\ could be reduced to the model-checking of \ctls. The model-checking of \ctls\ is itself known to be reducable to the model-checking of \ltl\ [?], another classical Temporal Logic.
We previously defined and model-checked \ctlskd\ in a multi-agent setting. However, this work will focus on the implementation of a \textbf{single-agent} \ctlskd\ model-checker. This choice was made for simplicity and the algorithm is almost identical.

In this report, I present my work on implementing a model-checker of \ctlskd. To this end, we use NuSMV [?], a \ltl\ model-checker, and build a \ctls\ model-checker, then a  \ctlskd\ model-checker, using the reductions.
The implementation is done in OCaml, and can be found online [?]. In a first section, we present the logics and their formalization, then the reductions. We then discuss the implementation itself. Finally, we present a way to evaluate our implementation.


\section{Formally Model-Checking \ctlskd}
Most of this section comes from our previous work [?,?]. More details can be found there.
The following sections will only focus on new work.

\subsection{Single agent \ctlskd}
\subsubsection{Syntax}

We begin by introducing the syntax of \ctlskd. 
We consider $\mathcal{O}$ to be a set of \textit{observations}, that each represent a possible observational power of the agent. $\mathit{AP}$ is a set of atomic propositions.
Formulas of \ctlskd\ can be \textit{history formulas} $\varphi$ or \textit{path formulas} $\psi$.

$$\varphi := p ~|~ \neg \varphi ~|~ \varphi\wedge\varphi ~|~ \varphi\vee\varphi ~|~ \A\psi ~|~ \E\psi ~|~ \K\varphi ~|~ \D{o}\varphi$$
$$\psi := \varphi ~|~ \neg\psi ~|~ \psi\wedge\psi ~|~ \X\psi ~|~ \psi\U\psi$$

Where $p\in\mathit{AP}$ and $o\in\mathcal{O}$.
The temporal operators $\X$ and $\U$ are meant to represent the typical \textit{next} and \textit{until} operators of temporal logics.
$\A$ is a path quantifier, similar to those found in branching-time logics. Intuitively, $\A\psi$ should hold for a history if $\psi$ is true in every possible future. $\E$ is $\A$'s dual.
$\K$ is an epistemic operator. Intuitively, $\K\varphi$ should be true whenever the agent knows that $\varphi$ is true. We introduce a new one, $\D{o}$, to represent a change of observation.
$\varphi$ is called a history formula, as we only need to know what happened in the past to decide if the formula is true. $\psi$ is called a path formula as it also requires the future evolution of the system.

\paragraph{Models}
The models on which such formulas can be interpreted are classical Kripke Structure, with several equivalence relations between states (one for each observation). We note $M=(S,I_s,o_I,T,V,\eqstate{o_1},\dots,\eqstate{o_m})$.
A \textit{run} or \textit{path} is an infinite sequence of states $\pi=\pi_0\pi_1\dots$. A \textit{history} is a finite sequence of states $h=h_1\dots h_n$.


\subsubsection{Record Semantics}
We first define the natural semantics of \ctlskd. To this end, we first define Observation Records.

\paragraph{Observation records}
Given $\mathcal{O}$ a set of observations, we define \textit{observations records} to be ordered lists of pairs of observations and natural numbers.
Intuitively, an observation record represents changes of observations.

\textbf{Example:}  $r=[(o_1,0),(o_2,3),(o_3,3)]$ means that the player starts at time 0 with observation $o_1$. It keeps this observation, then at time 3, it first changes to $o_2$ and then to $o_3$. We use observation records in the semantics to remember the previous observations of the agent.

We write $r[(o,n)]$ to append a new pair $(o,n)$ to the observation record $r$.
We write $r_{\leq n}$ the record $r$ without the pairs $(o,m)$ where $m>n$.
We write $r_n$ the record $r$ without the pairs $(o,m)$ where $m\neq n$. 
We define a function $\mathit{O}(r,n)$ which gives a tuple of the observations used at time $n$. 

On a given model, with an observation record we can define an equivalence relation between histories, with regard to a record. Two histories are equivalent with regard to the record if the player can't distinguish them by using the observations in the record.\\
$h\eqh{r}h'\quad\iff\quad \forall i< |h|, \forall o\in \mathit{O}(r,i), h(i)\eqstate{o} h'(i)~\textit{and}~|h|=|h'|.$


Finally, the semantics are defined as follows:
History formulas need a history $h$ (finite sequence of previous states) and an observation record $r$ to be interpreted, to know which history might be considered possible for the agent.
Path formulas are interpreted on a run $\pi$ (infinite sequence of states of the model), a point in time (natural number), and an observation record.

\begin{tabular}{l c l}
  $M,h,r \models p $&$ \iff $&$ p\in V(\mathit{last}(h))$\\
  $M,h,r \models \neg\varphi $&$ \iff $&$ M,h,r\not\models\varphi$\\
  $M,h,r \models \varphi_1\wedge\varphi_2 $&$ \iff $&$ (M,h,r\models\varphi_1~\text{and}~ M,h,r\models\varphi_2)$\\
  $M,h,r \models \varphi_1\vee\varphi_2 $&$ \iff $&$ (M,h,r\models\varphi_1~\text{or}~ M,h,r\models\varphi_2)$\\
  $M,h,r \models \A\psi  $&$ \iff $&$ \forall\pi$ that extends $h$, we have $M,\pi,|h|-1,r\models\psi$\\
  $M,h,r \models \E\psi  $&$ \iff $&$ \exists\pi$ that extends $h$, we have $M,\pi,|h|-1,r\models\psi$\\
  $M,h,r \models\K\varphi  $&$ \iff $&$ \forall h'$ such that $h'\eqh{r}h$, we have $M,h',r\models\varphi$\\
  $M,h,r \models \D{o}\varphi $&$ \iff $&$ M,h,r[(o,|h|-1)]\models\varphi$\\
  $M,\pi,n,r\models\varphi $&$ \iff $&$ M,(\pi_0\dots\pi_n),r\models\varphi$\\
  $M,\pi,n,r\models\neg\psi $&$ \iff $&$ M,\pi,n,r\not\models\psi$\\
  $M,\pi,n,r\models \psi_1\wedge\psi_2 $&$ \iff $&$ (M,\pi,r,n\models\psi_1~\text{and}~ M,\pi,r,n\models\psi_2)$\\
  $M,\pi,n,r\models\X\psi $&$ \iff $&$  M,\pi,(n+1),r\models\psi$\\
  $M,\pi,n,r\models \psi_1\U\psi_2 $&$ \iff $&$ \exists m\geq n$ such that $\forall k\in[n,m[, M,\pi,k,r\models\psi_1$\\
   & & and $M,\pi,m,r\models\psi_2$
\end{tabular}

Finally, we say that $M=(S,I_s,o_I,T,V,\eqstate{o_1},\dots,\eqstate{o_m})$ models $\varphi$ (written $M\models\varphi$), if $\forall s\in I_s, M,s,[(o_I,0)]\models\varphi$. This definition corresponds to the model-checking problem.

\subsection{Model-Checking \ctlskd}
Because of perfect-recall semantics, it may seem that we have to remember the complete history and records when evaluating a formula. However, we can extract some information from the history that is sufficient for the evaluation of the formula. Intuitively, to evaluate a history formula, it is enough to know the current state, the current observation and the set of states that the agent believes the system might be in (called the \textit{Information Set}). This new structure to represent the knowledge is more succinct than remembering entire histories and records, as there is a finite number of information sets.

We define two functions to update information sets. $\UD$ updates the set when a player goes through a change of observation and $\UT$ updates the set when the player moves to a new state. 
\begin{tabular}{r c c c l}
$\UD(I,s,o)$& = &$\{x\in I$ & $|$ & $x\eqstate{o}s\}$\\
$\UT(I,s,o)$& = &$\{x\in S$ & $|$ & $\exists t\in I, t\rightarrow x ~\text{and}~ x\eqstate{o}s\}$\\
\end{tabular}

A few rules from this new semantics are:
\begin{tabular}{l c l}
  $M,s,I,o\models p $&$ \iff $&$ p\in V(s)$\\
  $M,s,I,o\models\A\psi $&$ \iff $&$ \forall\pi$ such that $\pi_0=s$, we have $M,\pi,I,o\models\psi$\\
  $M,s,I,o\models\K\varphi $&$ \iff $&$ \forall s'\in I$, we have $M,s',I,o\models\varphi$\\
  $M,s,I,o'\models\D{o}\varphi $&$ \iff $&$ M,s,\UD(I,s,o),o\models\varphi$\\
  $M,\pi,I,o\models\X\psi $&$ \iff $&$ M,\pi_{1\dots},\UT(I,\pi_1,o),o\models\psi$\\
\end{tabular}

We proved in [?] the following theorem:
$\forall \varphi,h,r,s,I,o$ such that $\FV(h,r)=(s,I,o)$, $M,h,r\models\varphi\iff M,s,I,o\models\varphi$.
Where $\FV$ is a function that relates histories and observation records to the corresponding current state, information set and observation.
This proves that the two semantics are equivalent, and it suffices to model-check the information set semantics.

To this end, from $M=(S,I,o_I,T,V,\eqstate{o_1},\dots,\eqstate{o_m})$ we define the augmented model $\hat{M}=(S',T',V')$, a Kripke Structure.
\begin{itemize}
\item $S'=S\times 2^{S}\times \mathcal{O}$: states are state of the original model, an observation set and an observation.
\item $(s,I,o)~T'~(s',I',o)\iff s~T~s'$ and $I'=\UT(I,s',o)$
\item $V'(s,I,o)=V(s)$. As the algorithm is executed, new atomic propositions will appear.
\end{itemize}

Finally, any formula of \ctlskd can be model-checked with a marking algorithm on the (finite) augmented model.
Intuitively, for each $\D{o}\varphi$ where $\varphi$ is a \ctls\ formula, we model-check $\varphi$ on each state of $\hat{M}$.
Then, we mark each state $(s,I,o')$ of $\hat{M}$ with a new atomic proposition if $\varphi$ holds on $(s,\UD(I,s,o),o)$.
Similarly for formulas $\K\varphi$ where $\varphi$ is a \ctls\ formula, a state $(s,I,o)$ is marked with a new atomic proposition if $\varphi$ holds in each $(s',I,o)$ where $s'\in I$.

Finally, we replace either $\D{o}\varphi$ or $\K\varphi$ in the formula with the new atomic proposition, and start from the beginning until there are no more $\K$ or $\Delta$ operators in the formula. The remaining formula can be model-checked with the \ctls\ model-checker.

The definition of the Information Set semantics makes the correctness of the algorithm almost trivial.

\section{Implementation}

\subsection{Types}
Our models can either be standard models, where each state can be numbered, or augmented models for the model-checking of \ctlskd.
States of augmented models include a standard state, an information set and an observation

Thus we define our states as such:
\begin{lstlisting}
  type std_state = int
  type inf_set = std_state list
  type state = I of std_state
             | A of std_state * inf_set * observation
\end{lstlisting}

When building augmented states, we make sure that the information sets have no duplicates and are ordered, which guarantees that each augmented state has a unique representation.

Kripke structure are then defined. The \texttt{kripke} type represents the states and transition of a Kripke Structure: each element of the list is a state and its list of successors.
A marking represents the valuation function. Each element of the list contains an atomic proposition and the list of states wher it holds.
Decoupling the two types allows to add new atomic propositions without changing the underlying structure easily, which will prove useful for marking algorithms.
Observations equivalence relations are described with the \texttt{obs\_marking} type. It maps observations and states to a value. 

\begin{lstlisting}
  type kripke = (state * state list) list
  type std_kripke = (std_state * std_state list) list
  type marking = (atp * state list) list
  type std_marking = (atp * std_state list) list
  module ObsMap = Map.Make(struct type t = (observation * std_state) let compare = compare end)
  type obs_marking = int ObsMap.t
  let eq_state (om:obs_marking) (o:observation) (s1:std_state) (s2:std_state): bool =
    ObsMap.find (o,s1) om = ObsMap.find (o,s2) om
\end{lstlisting}


We then define the 3 logics' syntaxes:
\begin{lstlisting}
type ltl =
  | LTL_TRUE
  | LTL_AP of atp
  | LTL_NEG of ltl
  | LTL_OR of ltl* ltl
  | LTL_AND of ltl* ltl
  | LTL_X of ltl
  | LTL_U of ltl* ltl

type state_ctls =
  | ST_CTLS_TRUE
  | ST_CTLS_AP of atp
  | ST_CTLS_NEG of state_ctls
  | ST_CTLS_OR of state_ctls * state_ctls
  | ST_CTLS_AND of state_ctls * state_ctls
  | ST_CTLS_A of path_ctls
  | ST_CTLS_E of path_ctls
 and path_ctls =
   | P_CTLS_S of state_ctls
   | P_CTLS_NEG of path_ctls
   | P_CTLS_OR of path_ctls * path_ctls
   | P_CTLS_AND of path_ctls * path_ctls
   | P_CTLS_X of path_ctls
   | P_CTLS_U of path_ctls * path_ctls

type history_ctlskd =
  | H_CTLSKD_TRUE
  | H_CTLSKD_AP of atp
  | H_CTLSKD_NEG of history_ctlskd
  | H_CTLSKD_OR of history_ctlskd * history_ctlskd
  | H_CTLSKD_AND of history_ctlskd * history_ctlskd
  | H_CTLSKD_A of path_ctlskd
  | H_CTLSKD_E of path_ctlskd
  | H_CTLSKD_K of history_ctlskd
  | H_CTLSKD_D of observation * history_ctlskd
 and path_ctlskd =
   | P_CTLSKD_H of history_ctlskd
   | P_CTLSKD_NEG of path_ctlskd
   | P_CTLSKD_OR of path_ctlskd * path_ctlskd
   | P_CTLSKD_AND of path_ctlskd * path_ctlskd
   | P_CTLSKD_X of path_ctlskd
   | P_CTLSKD_U of path_ctlskd * path_ctlskd
\end{lstlisting}


Given these types, we can define the signature of our 3 model-checking procedures:

\begin{lstlisting}
  let ltl_mc (k:kripke) (init:state) (m:marking) (spec:ltl): bool = ...
  let ctls_mc (k:kripke) (init:state) (m:marking) (spec:state_ctls): bool = ...
  let ctlskd_mc (k:std_kripke) (state_init:std_state) (m:std_marking) (obs_init:observation) (om:obs_marking) (spec:history_ctlskd): bool = ...
\end{lstlisting}

Notice how \ltl\ and \ctls\ model-checkers take as input generic kripke structure (either standard or augmented), while the \ctlskd\ function takes a standard kripke structure. It will then build the augmented model and give it to the \ctls\ function, which in turn calls the \ltl\ one on the same model.
Similarly, as only \ctlskd\ has imperfect information, its function is the only one requiring an observation marking and an initial observation.

\subsection{\ltl\ Model-Checking}
As we use NuSMV, a \ltl\ model-checker, our model-checking procedure can simply call it.
However, NuSMV only works on an input file. We then write several functions to translate a \ltl\ model-checking problem as a file following the syntax of NuSMV.
We then call the NuSMV executable on this file. Because its output is a long string, we write a small wrapper in C to analyze it and simply return 1 or 0 depending on the result. This returned value can be obtained in Ocaml by using the \texttt{Sys.command} function.

\subsection{\ctls\ Model-Checking}

\subsection{\ctlskd\ Model-Checking}


\section{Evaluation}
% general stuff (size, no parser etc.)
% generic tests
% parametric tests
% complexity

\section{Future Works}
% multi agent
% parser
% binding nusmv
% other solvers
% rigorous testing
% reduce size of augmented model

\section{Conclusion}



\end{document}
